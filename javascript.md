# 原生JavaScript

## 作用域
JavaScript有两种作用域

 - 全局作用域
 - 函数作用域

在ES6之后又增加了一种
 - 块级作用域

没有被任何中括号包裹的变量和函数都会被放入全局作用域。
在全局作用域中，所有的函数都会被保存为window对象的方法，所有变量都会保存为window对象的属性。
全局作用域中所有的变量都是全局变量，所有的函数都是全局函数，在任何作用域里都可以访问。

被定义函数的中括号包裹的变量和函数会被放入函数作用域。
在函数作用域的变量为局部变量，只有在当前的作用域内可以访问这个局部变量，局部变量在当前的作用域中会覆盖全局作用域和父级作用域中的同名变量。
在函数作用域的变量为局部函数，只有在当前的作用域内可以访问这个局部函数，局部函数在当前的作用域中会覆盖全局作用域和父级作用域中的同名函数。

被任何代码块包裹，使用`let`或`const`定义的变量，会被放入块级作用域。
任何代码块都可以被看做是块级作用域，所以全局作用域也于块级作用域，函数作用域也属于块级作用域。
块级作用域中的变量和函数与函数作用域中的特性相同，但是必须使用`let`或者`const`定义才会生效，如果使用`var`定义变量和函数，或者直接用`function`定义函数，都不会被放入块级作用域，而是会被放入父级的作用域。


## var，const，let的区别
在JavaScript中可以使用var定义变量，在ES6后新增了`const`与`let`。

`var`具有域提升的特性。域提升是指JavaScript会把所有使用`var`定义的变量语句提升到当前作用域的顶部，导致的结果就是变量可以先使用后定义。在使用`var`定义这个变量之前且没有为这个变量赋值过的时候，这个变量的值会是`undefined`。但使用完全没有被`var`定义的变量依旧会导致变量未定义错误。

```javascript
console.log(a); // 输出 undefined
a = "1"
console.log(a); // 输出 1
var a = "a"
console.log(a); // 输出 a
console.log(b); // 报错 因为没有定义变量b
```

`const`和`let`都支持块级作用域。`const`与`let`不同的是，`const`定义的变量不能重新赋值，所以`const`定义时必须要赋予初始值。但是值得注意的是，虽然变量本身不能被赋值，但是引用类型的变量内部的数据依旧是可以被赋值的。

```javascript
const a // 报错 因为没有赋初始值
const b = [1, 2, 3]
console.log(b); // 输出 [1, 2, 3]
b = [1, 2, 3, 4] // 报错 因为不能重新赋值
b[0] = "x"
console.log(b); // 输出 [x, 2, 3]
```

## 闭包(Closure)
>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。